# Data Model: Makefile Build Tools Configuration

**Feature**: 001-makefile-build-tools
**Date**: 2025-11-23

## Overview

This document defines the configuration data structures, environment state, and file formats used by the Makefile build automation system. Since this is a development tooling feature rather than an application, the "data model" consists of configuration files, environment variables, and tool state.

## Configuration Files

### 1. .python-version

**Purpose**: Specifies the required Python version for the project

**Format**: Plain text, single line
```
3.12.12
```

**Fields**:
- **version**: String in format `MAJOR.MINOR.PATCH` (e.g., "3.12.12")

**Used By**:
- pyenv (automatic version activation)
- Makefile (validation checks)

**Validation Rules**:
- Must be a valid Python version available in pyenv
- Must match `^[0-9]+\.[0-9]+\.[0-9]+$` pattern

---

### 2. pyproject.toml

**Purpose**: Poetry configuration and project metadata

**Format**: TOML configuration file

**Key Sections**:

```toml
[tool.poetry]
name = "project-name"
version = "0.1.0"
description = "Project description"
python = "^3.10"  # Python version constraint

[tool.poetry.dependencies]
python = "^3.10"
# ... dependencies

[tool.poetry.group.dev.dependencies]
pytest = "^8.0.0"
ruff = "^0.11.13"
# ... dev dependencies

[tool.ruff]
line-length = 120
target-version = "py312"

[tool.ruff.lint]
select = ["E", "W", "F", "I", "B", "C4", "UP"]
ignore = ["E501"]

[tool.ruff.format]
quote-style = "double"
indent-style = "space"
```

**Fields** (relevant to build tooling):
- **tool.poetry.name**: Project name (string)
- **tool.poetry.python**: Python version constraint (string)
- **tool.poetry.dependencies**: Runtime dependencies (dict)
- **tool.poetry.group.dev.dependencies**: Development dependencies (dict)
- **tool.ruff.\***: Ruff linter/formatter configuration

**Used By**:
- Poetry (dependency management)
- Ruff (linting/formatting rules)
- Makefile (reads to verify configuration)

**Validation Rules**:
- Must be valid TOML syntax
- Must contain `[tool.poetry]` section
- Python version must be compatible with .python-version

---

### 3. poetry.lock

**Purpose**: Lock file for exact dependency versions

**Format**: TOML (generated by Poetry)

**Characteristics**:
- Auto-generated by `poetry install` or `poetry update`
- Contains exact versions and hashes for all dependencies
- Should be committed to version control for reproducibility
- Not manually edited

**Used By**:
- Poetry (ensures reproducible installs)

---

### 4. Makefile

**Purpose**: Build automation and task orchestration

**Format**: GNU Make syntax

**Structure**:
```makefile
# Variables
PYTHON_VERSION := $(shell cat .python-version)
POETRY_VERSION := 2.2.1
POETRY_BIN := $(HOME)/.local/bin/poetry

# Special targets
.PHONY: [target-names]
.DEFAULT_GOAL := help
.ONESHELL:

# Targets (documented with ##)
target-name: dependencies ## Description
	@commands
```

**Key Components**:
- **Variables**: Configuration values (Python version, paths, flags)
- **Targets**: Executable tasks (setup, test, lint, build, clean)
- **Dependencies**: Target prerequisites
- **Recipes**: Shell commands to execute
- **Documentation**: Inline comments with `##` for help generation

**Target Categories**:
1. **Setup**: install-pyenv-check, install-poetry, setup
2. **Code Quality**: lint, format, lint-fix
3. **Testing**: test, test-cov
4. **Building**: build (if applicable)
5. **Maintenance**: clean
6. **Documentation**: help

---

## Environment State

### Tool Installation State

**Components**:
```
Tool Installation {
  pyenv: {
    installed: boolean
    version: string
    python_versions: list[string]
    active_version: string
  }

  poetry: {
    installed: boolean
    version: string
    location: path
    config: {
      virtualenvs_in_project: boolean
    }
  }

  python_env: {
    version: string
    location: path
    virtualenv_active: boolean
    virtualenv_path: path
  }

  ruff: {
    installed: boolean (via poetry)
    version: string
    available: boolean (in poetry env)
  }
}
```

**State Transitions**:
1. **Initial**: No tools installed
2. **pyenv Detected**: pyenv found in PATH
3. **Python Installed**: Required Python version available via pyenv
4. **Poetry Installed**: Poetry available in PATH
5. **Dependencies Installed**: poetry install completed, .venv exists
6. **Fully Configured**: All tools present and validated

**Validation Checks** (per state):
- pyenv: `command -v pyenv`
- Python version: `pyenv versions | grep $(PYTHON_VERSION)`
- Poetry: `command -v poetry`
- Virtual env: `[ -d .venv ]`
- Ruff: `poetry run ruff --version`

---

## File Paths and Locations

### System Paths

```
/Users/username/
├── .pyenv/
│   ├── versions/
│   │   └── 3.12.12/        # Installed Python version
│   └── version             # Global Python version
│
└── .local/
    ├── bin/
    │   └── poetry          # Poetry executable
    └── share/
        └── pypoetry/       # Poetry installation
```

### Project Paths

```
/project-root/
├── .python-version         # pyenv version specification
├── pyproject.toml          # Poetry configuration
├── poetry.lock             # Locked dependencies
├── Makefile                # Build automation
├── .venv/                  # Poetry virtual environment
│   ├── bin/
│   │   ├── python
│   │   ├── pytest
│   │   └── ruff
│   └── lib/
│       └── python3.12/
│           └── site-packages/
├── src/                    # Source code
└── tests/                  # Test files
```

---

## Configuration Validation Rules

### Cross-File Consistency

1. **Python Version Consistency**:
   - `.python-version` must match `pyproject.toml` `tool.poetry.python` constraint
   - Active Python version (pyenv) must match `.python-version`

2. **Poetry Environment**:
   - `.venv` directory must exist after `poetry install`
   - `.venv/bin/python` version must match `.python-version`

3. **Dependency Versions**:
   - `poetry.lock` must be present and in sync with `pyproject.toml`
   - Ruff version in `poetry.lock` must match `pyproject.toml` specification

### Validation Sequence (Makefile)

```makefile
validate: validate-python validate-poetry validate-deps
	@echo "✓ All validations passed"

validate-python:
	@# Check .python-version exists
	@# Check pyenv has version installed
	@# Check active Python matches

validate-poetry:
	@# Check poetry installed
	@# Check virtualenvs.in-project = true
	@# Check .venv exists

validate-deps:
	@# Check poetry.lock exists
	@# Check lock file is up to date
```

---

## Error States and Handling

### Common Error States

| Error State | Detection | Resolution |
|-------------|-----------|------------|
| pyenv not installed | `command -v pyenv` fails | User must install pyenv manually |
| Python version missing | `pyenv versions` doesn't list version | Run `pyenv install $(PYTHON_VERSION)` |
| Poetry not installed | `command -v poetry` fails | Makefile auto-installs via official installer |
| Poetry version mismatch | `poetry --version` != expected | Makefile warns, continues |
| Lock file out of sync | `poetry check` fails | Run `poetry lock --no-update` |
| Virtual env missing | `.venv` directory absent | Run `poetry install` |
| Dependency installation failure | `poetry install` exits non-zero | Check network, Python version, lock file |

### Error Message Format

```makefile
@echo "ERROR: [Problem description]"
@echo ""
@echo "Resolution:"
@echo "  [Step-by-step fix instructions]"
@echo ""
@echo "Example:"
@echo "  [Concrete command example]"
@exit 1
```

---

## Data Flow

### Setup Flow

```
User runs: make setup
    ↓
Check .python-version exists
    ↓
Check pyenv installed → [ERROR if missing]
    ↓
Check Python version installed → [ERROR with install command]
    ↓
Check poetry installed → [Auto-install if missing]
    ↓
Configure poetry (virtualenvs.in-project = true)
    ↓
Run: poetry install
    ↓
Validate .venv created
    ↓
SUCCESS: Environment ready
```

### Lint/Format Flow

```
User runs: make lint-fix
    ↓
Check .venv exists → [ERROR if missing]
    ↓
Run: poetry run ruff check --fix .
    ↓
Run: poetry run ruff format .
    ↓
Report results
```

### Test Flow

```
User runs: make test
    ↓
Check .venv exists → [ERROR if missing]
    ↓
Run: poetry run pytest
    ↓
Report results (pass/fail counts)
```

---

## Summary

This data model defines:

1. **Configuration Files**: .python-version, pyproject.toml, poetry.lock, Makefile
2. **Environment State**: Tool installation status, version tracking, path locations
3. **Validation Rules**: Cross-file consistency checks, state transitions
4. **Error Handling**: Detection, messaging, resolution paths
5. **Data Flow**: Setup, lint, format, test operation sequences

All data is stored in text configuration files (no database), making it git-friendly and human-readable. The Makefile orchestrates state transitions and ensures consistency across the development environment.
