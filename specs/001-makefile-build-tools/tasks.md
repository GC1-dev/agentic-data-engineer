# Tasks: Makefile Build Tools Configuration

**Input**: Design documents from `/specs/001-makefile-build-tools/`
**Prerequisites**: plan.md, spec.md, research.md, data-model.md, contracts/makefile-interface.md

**Tests**: Not applicable for this feature (infrastructure tooling, no application tests needed)

**Organization**: Tasks are grouped by user story to enable independent implementation and testing of each story.

## Format: `[ID] [P?] [Story] Description`

- **[P]**: Can run in parallel (different files, no dependencies)
- **[Story]**: Which user story this task belongs to (e.g., US1, US2, US3)
- Include exact file paths in descriptions

## Path Conventions

This is a repository infrastructure feature. The main deliverable is:
- **Makefile** at repository root: `/Makefile`
- Existing configuration files: `/.python-version`, `/pyproject.toml`, `/requirements.txt`

---

## Phase 1: Setup (Shared Infrastructure)

**Purpose**: Verify existing configuration files and prepare for Makefile creation

- [x] T001 Verify .python-version file exists at repository root
- [x] T002 Verify pyproject.toml file exists and contains required tool.poetry and tool.ruff sections
- [x] T003 Verify poetry.lock file exists (generated by prior setup)

---

## Phase 2: Foundational (Blocking Prerequisites)

**Purpose**: Core Makefile structure that MUST be complete before any user story targets can be added

**‚ö†Ô∏è CRITICAL**: No user story work can begin until this phase is complete

- [x] T004 Create Makefile skeleton with POSIX compatibility settings (SHELL, .PHONY, .DEFAULT_GOAL)
- [x] T005 Add Makefile variables section (PYTHON_VERSION from .python-version, POETRY_VERSION, POETRY_BIN paths)
- [x] T006 Implement help target as default goal with self-documentation pattern per research.md section 6
- [x] T007 Add .PHONY declarations for all target names to prevent conflicts with files

**Checkpoint**: Foundation ready - user story targets can now be added in parallel

---

## Phase 3: User Story 1 - Quick Environment Setup (Priority: P1) üéØ MVP

**Goal**: Provide single-command setup that verifies pyenv, auto-installs poetry, and installs dependencies

**Independent Test**: Run `make setup` on a fresh clone (with pyenv installed) and verify .venv directory created, poetry available, and all dependencies installed

### Implementation for User Story 1

- [x] T008 [P] [US1] Implement check-pyenv target in Makefile to detect pyenv and verify Python version per research.md section 2
- [x] T009 [P] [US1] Implement install-poetry target in Makefile to auto-install poetry if missing per research.md section 3
- [x] T010 [US1] Implement install-deps target in Makefile to configure poetry and run poetry install --no-root
- [x] T011 [US1] Implement setup target in Makefile that orchestrates check-pyenv, install-poetry, and install-deps
- [x] T012 [US1] Add idempotency checks to setup targets per research.md section 5 (check before install, provide status messages)
- [x] T013 [US1] Add validate target in Makefile to check environment state (pyenv, poetry, .venv, Python version consistency)
- [x] T014 [US1] Add error handling with actionable messages per research.md section 8 (fail fast, remediation steps)

**Checkpoint**: At this point, `make setup` should fully configure the development environment on a fresh clone

---

## Phase 4: User Story 2 - Code Quality Checks (Priority: P2)

**Goal**: Provide simple commands for code linting and formatting using ruff

**Independent Test**: Create a Python file with linting issues, run `make lint` to detect them, and `make lint-fix` to fix them automatically

### Implementation for User Story 2

- [x] T015 [P] [US2] Implement lint target in Makefile to run ruff check per research.md section 4
- [x] T016 [P] [US2] Implement format target in Makefile to run ruff format
- [x] T017 [US2] Implement lint-fix target in Makefile to run ruff check --fix followed by ruff format
- [x] T018 [US2] Add dependency checks to code quality targets (verify .venv exists, fail with helpful message if missing)
- [x] T019 [US2] Add inline documentation (## comments) for each code quality target for self-documenting help

**Checkpoint**: At this point, `make lint`, `make format`, and `make lint-fix` should all work independently

---

## Phase 5: User Story 3 - Build and Test Workflow (Priority: P3)

**Goal**: Provide commands for running tests, building the project, and cleaning artifacts

**Independent Test**: Run `make test` to execute pytest, `make build` to create distributable, and `make clean` to remove all generated files

### Implementation for User Story 3

- [x] T020 [P] [US3] Implement test target in Makefile to run poetry run pytest -v
- [x] T021 [P] [US3] Implement test-cov target in Makefile to run pytest with coverage (--cov=src --cov-report=html --cov-report=term)
- [x] T022 [P] [US3] Implement build target in Makefile to run poetry build
- [x] T023 [P] [US3] Implement clean target in Makefile to remove dist/, build/, __pycache__, *.pyc, .pytest_cache, .ruff_cache, htmlcov/, .coverage per research.md section 10
- [x] T024 [US3] Add dependency checks to test/build targets (verify .venv exists)
- [x] T025 [US3] Add inline documentation (## comments) for each build/test target

**Checkpoint**: All user stories should now be independently functional - complete development workflow available

---

## Phase 6: Polish & Cross-Cutting Concerns

**Purpose**: Improvements that affect multiple user stories and final validation

- [x] T026 [P] Verify all targets have inline documentation comments (## syntax for help extraction)
- [x] T027 [P] Test Makefile idempotency by running `make setup` twice and verifying no errors
- [x] T028 [P] Test all error messages display properly when prerequisites missing (e.g., run check-pyenv without pyenv)
- [x] T029 Verify help target correctly displays all targets with their descriptions
- [x] T030 Run through quickstart.md validation scenarios to ensure all commands work as documented
- [x] T031 [P] Add .ONESHELL directive if needed for complex multi-line recipes (optional optimization)
- [x] T032 Test cross-platform compatibility (verify on macOS, document WSL requirements for Windows per research.md section 7)

---

## Dependencies & Execution Order

### Phase Dependencies

- **Setup (Phase 1)**: No dependencies - can start immediately
- **Foundational (Phase 2)**: Depends on Setup completion - BLOCKS all user stories
- **User Stories (Phase 3-5)**: All depend on Foundational phase completion
  - User stories can then proceed in parallel (if staffed)
  - Or sequentially in priority order (P1 ‚Üí P2 ‚Üí P3)
- **Polish (Phase 6)**: Depends on all user stories being complete

### User Story Dependencies

- **User Story 1 (P1)**: Can start after Foundational (Phase 2) - No dependencies on other stories
- **User Story 2 (P2)**: Can start after Foundational (Phase 2) - No dependencies on other stories
- **User Story 3 (P3)**: Can start after Foundational (Phase 2) - No dependencies on other stories

**All user stories are independent** - they can be implemented in parallel by different developers

### Within Each User Story

- Tasks marked [P] within a story can run in parallel (different Makefile sections/targets)
- Error handling and documentation tasks should come after core implementation
- Validation tasks should come last within each story

### Parallel Opportunities

- All Setup tasks (T001-T003) can run in parallel
- Foundational tasks T005-T007 can run in parallel after T004 completes
- Once Foundational phase completes:
  - User Story 1 tasks T008-T009 can run in parallel
  - User Story 2 tasks T015-T017 can run in parallel
  - User Story 3 tasks T020-T023 can run in parallel
- All user stories can be worked on in parallel by different team members
- Polish tasks T026-T028 and T032 can run in parallel

---

## Parallel Example: User Story 1

```bash
# After Foundational phase complete, launch these tasks together:
Task: "Implement check-pyenv target in Makefile"
Task: "Implement install-poetry target in Makefile"

# These can also run in parallel (different targets):
Task: "Add validate target in Makefile"
Task: "Add error handling with actionable messages"
```

## Parallel Example: User Story 2

```bash
# All core targets can be written in parallel (independent Makefile sections):
Task: "Implement lint target in Makefile"
Task: "Implement format target in Makefile"
Task: "Implement lint-fix target in Makefile"
```

## Parallel Example: User Story 3

```bash
# All build/test targets can be written in parallel:
Task: "Implement test target in Makefile"
Task: "Implement test-cov target in Makefile"
Task: "Implement build target in Makefile"
Task: "Implement clean target in Makefile"
```

---

## Implementation Strategy

### MVP First (User Story 1 Only)

1. Complete Phase 1: Setup (verify existing files)
2. Complete Phase 2: Foundational (create Makefile skeleton, help target)
3. Complete Phase 3: User Story 1 (setup, validation targets)
4. **STOP and VALIDATE**: Test `make setup` on fresh clone
5. Deploy/use if ready - developers can now onboard quickly

**MVP Deliverable**: Single `make setup` command that configures entire development environment

### Incremental Delivery

1. Complete Setup + Foundational ‚Üí Makefile exists with help
2. Add User Story 1 ‚Üí Test `make setup` ‚Üí Onboarding complete! (MVP!)
3. Add User Story 2 ‚Üí Test `make lint-fix` ‚Üí Code quality automation
4. Add User Story 3 ‚Üí Test `make test` ‚Üí Full development workflow
5. Each story adds value without breaking previous stories

### Parallel Team Strategy

With multiple developers:

1. Team completes Setup + Foundational together (T001-T007)
2. Once Foundational is done:
   - Developer A: User Story 1 (environment setup targets)
   - Developer B: User Story 2 (code quality targets)
   - Developer C: User Story 3 (build/test targets)
3. Stories complete independently, all targets merged into single Makefile
4. Parallel development safe because each story adds distinct, non-overlapping targets

---

## Task Mapping to Requirements

### Functional Requirements Coverage

| Requirement | Tasks |
|-------------|-------|
| FR-001: pyenv target | T008 |
| FR-002: poetry target | T009 |
| FR-003: dependencies target | T010 |
| FR-004: ruff configuration | T015-T017 |
| FR-005: ruff checks | T015 |
| FR-006: auto-fix issues | T017 |
| FR-007: test suite | T020-T021 |
| FR-008: build project | T022 |
| FR-009: clean artifacts | T023 |
| FR-010: help target | T006 |
| FR-011: tool availability checks | T008, T014, T018, T024 |
| FR-012: idempotent targets | T012 |

### Makefile Targets to Implement

| Target | User Story | Tasks |
|--------|------------|-------|
| help | Foundation | T006 |
| check-pyenv | US1 | T008 |
| install-poetry | US1 | T009 |
| install-deps | US1 | T010 |
| setup | US1 | T011 |
| validate | US1 | T013 |
| lint | US2 | T015 |
| format | US2 | T016 |
| lint-fix | US2 | T017 |
| test | US3 | T020 |
| test-cov | US3 | T021 |
| build | US3 | T022 |
| clean | US3 | T023 |

---

## Success Criteria Validation

| Success Criterion | Validation Task |
|-------------------|-----------------|
| SC-001: Setup in <5 min | T030 (quickstart validation) |
| SC-002: Lint in <30 sec | T030 (performance check) |
| SC-003: Works on 2+ platforms | T032 (cross-platform testing) |
| SC-004: 100% auto-install | T011-T013 (setup orchestration) |
| SC-005: Self-documenting | T006, T026, T029 (help system) |

---

## Notes

- [P] tasks = different Makefile targets/sections, no dependencies
- [Story] label maps task to specific user story for traceability
- Each user story should be independently completable and testable
- No tests needed (infrastructure feature - validated via actual usage)
- Commit after each task or logical group of related targets
- Stop at any checkpoint to validate story independently
- All tasks create or modify the single `/Makefile` at repository root
- Follow patterns from research.md for all implementations
- Reference contracts/makefile-interface.md for exact target specifications
